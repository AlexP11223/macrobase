package alexp.macrobase.pipeline;

import alexp.macrobase.explanation.Itemset;
import alexp.macrobase.utils.DataFrameUtils;
import edu.stanford.futuredata.macrobase.analysis.summary.Explanation;
import edu.stanford.futuredata.macrobase.datamodel.DataFrame;
import edu.stanford.futuredata.macrobase.util.MacroBaseException;
import org.apache.commons.lang3.StringUtils;

import java.io.IOException;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;

public abstract class Pipeline {
    protected long lastGeneratedTime = -1;

    private String outputDir;

    private boolean outputIncludesInliers = false;

    public String getOutputDir() {
        return outputDir;
    }

    public void setOutputDir(String outputDir) {
        this.outputDir = outputDir;
    }

    public boolean isOutputIncludesInliers() {
        return outputIncludesInliers;
    }

    public void setOutputIncludesInliers(boolean outputIncludesInliers) {
        this.outputIncludesInliers = outputIncludesInliers;
    }

    protected void createAutoGeneratedColumns(DataFrame dataFrame, String... columns) {
        Arrays.stream(columns).filter(Pipelines::isAutoGeneratedColumn).forEach(column -> {
            switch (column) {
                case "__autogenerated_time": {
                    Pipelines.generateTimeColumn(dataFrame, column, lastGeneratedTime + 1);
                    double[] values = dataFrame.getDoubleColumnByName(column);
                    lastGeneratedTime = (long) values[values.length - 1];
                }
                break;
                default:
                    throw new RuntimeException("Unknown column " + column);
            }
        });
    }

    protected void saveData(String dir, String baseFileName, DataFrame data) throws IOException {
        DataFrameUtils.saveToCsv(Paths.get(dir, baseFileName + ".csv").toString(), data);
    }

    protected void saveData(String baseFileName, DataFrame data) throws IOException {
        if (StringUtils.isEmpty(getOutputDir())) {
            return;
        }

        saveData(getOutputDir(), baseFileName, data);
    }

    protected void saveOutliers(String baseFileName, DataFrame data, String outlierOutputColumn) throws IOException {
        if (StringUtils.isEmpty(getOutputDir())) {
            return;
        }

        if (!outputIncludesInliers) {
            data = data.filter(outlierOutputColumn, this::isOutlier);
        }

        saveData(baseFileName, data);
    }

    protected void saveExplanation(String baseFileName, DataFrame data, String outlierOutputColumn, Explanation explanation) throws IOException, MacroBaseException {
        if (StringUtils.isEmpty(getOutputDir())) {
            return;
        }

        List<Itemset> itemsets = Pipelines.getItemsets(explanation);

        if (!outputIncludesInliers) {
            data = data.filter(outlierOutputColumn, this::isOutlier);
        }

        for (int i = 0; i < itemsets.size(); i++) {
            Itemset itemset = itemsets.get(i);

            DataFrame result = DataFrameUtils.filterByAll(data, itemset.getAttributes());

            saveData(baseFileName + "_group" + (i + 1), result);
        }
    }

    private boolean isOutlier(double value) {
        return value > 0.0;
    }
}
