package alexp.macrobase.pipeline;

import alexp.macrobase.utils.DataFrameUtils;
import edu.stanford.futuredata.macrobase.analysis.classify.Classifier;
import edu.stanford.futuredata.macrobase.datamodel.DataFrame;
import org.apache.commons.lang3.StringUtils;

import java.io.IOException;
import java.nio.file.Paths;
import java.util.Arrays;

public abstract class Pipeline {
    protected long lastGeneratedTime = -1;

    private String outputDir;

    private boolean outputIncludesInliers = false;

    public String getOutputDir() {
        return outputDir;
    }

    public void setOutputDir(String outputDir) {
        this.outputDir = outputDir;
    }

    public boolean isOutputIncludesInliers() {
        return outputIncludesInliers;
    }

    public void setOutputIncludesInliers(boolean outputIncludesInliers) {
        this.outputIncludesInliers = outputIncludesInliers;
    }

    protected void createAutoGeneratedColumns(DataFrame dataFrame, String... columns) {
        Arrays.stream(columns).filter(Pipelines::isAutoGeneratedColumn).forEach(column -> {
            switch (column) {
                case "__autogenerated_time": {
                    Pipelines.generatedTimeColumn(dataFrame, column, lastGeneratedTime + 1);
                    double[] values = dataFrame.getDoubleColumnByName(column);
                    lastGeneratedTime = (long) values[values.length - 1];
                }
                break;
                default:
                    throw new RuntimeException("Unknown column " + column);
            }
        });
    }

    protected void saveData(String baseFileName, DataFrame data) throws IOException {
        if (StringUtils.isEmpty(outputDir)) {
            return;
        }

        DataFrameUtils.saveToCsv(Paths.get(outputDir, baseFileName + ".csv").toString(), data);
    }

    protected void saveOutliers(String baseFileName, Classifier classifier) throws IOException {
        if (StringUtils.isEmpty(outputDir)) {
            return;
        }

        DataFrame data = classifier.getResults();
        if (!outputIncludesInliers) {
            data = data.filter(classifier.getOutputColumnName(), (double v) -> v > 0.0);
        }

        saveData(baseFileName, data);
    }
}
