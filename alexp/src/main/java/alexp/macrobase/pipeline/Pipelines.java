package alexp.macrobase.pipeline;

import alexp.macrobase.ingest.SqlDataFrameReader;
import alexp.macrobase.ingest.Uri;
import alexp.macrobase.ingest.XlsxDataFrameReader;
import alexp.macrobase.outlier.MAD;
import alexp.macrobase.outlier.MinCovDet;
import alexp.macrobase.outlier.lof.bkaluza.LOF;
import alexp.macrobase.outlier.mcod.McodClassifier;
import edu.stanford.futuredata.macrobase.analysis.classify.Classifier;
import edu.stanford.futuredata.macrobase.analysis.classify.PercentileClassifier;
import edu.stanford.futuredata.macrobase.analysis.classify.PredicateClassifier;
import edu.stanford.futuredata.macrobase.analysis.summary.Explanation;
import edu.stanford.futuredata.macrobase.analysis.summary.aplinear.APLOutlierSummarizer;
import edu.stanford.futuredata.macrobase.analysis.summary.fpg.FPGExplanation;
import edu.stanford.futuredata.macrobase.analysis.summary.fpg.FPGrowthSummarizer;
import edu.stanford.futuredata.macrobase.analysis.summary.fpg.IncrementalSummarizer;
import edu.stanford.futuredata.macrobase.datamodel.DataFrame;
import edu.stanford.futuredata.macrobase.datamodel.Schema;
import edu.stanford.futuredata.macrobase.operator.Operator;
import edu.stanford.futuredata.macrobase.operator.WindowedOperator;
import edu.stanford.futuredata.macrobase.pipeline.PipelineConfig;
import edu.stanford.futuredata.macrobase.pipeline.PipelineUtils;
import edu.stanford.futuredata.macrobase.util.MacroBaseException;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.LongStream;

public class Pipelines {
    public static DataFrame loadDataFrame(
            Uri inputURI,
            Map<String, Schema.ColType> colTypes,
            List<String> requiredColumns,
            PipelineConfig conf) throws Exception {
        requiredColumns = requiredColumns.stream().filter(c -> c != null && !isAutoGeneratedColumn(c)).collect(Collectors.toList());

        switch (inputURI.getType()) {
            case XLSX:
                return new XlsxDataFrameReader(inputURI.getPath(), requiredColumns, 0).load();
            case JDBC:
                return new SqlDataFrameReader(inputURI.getPath(), requiredColumns, conf.get("query")).load();
            default:
                return PipelineUtils.loadDataFrame(inputURI.getOriginalString(), colTypes, requiredColumns);
        }
    }

    public static Classifier getClassifier(PipelineConfig conf, String[] metricColumns) throws MacroBaseException {
        String classifierType = conf.get("classifier");

        switch (classifierType.toLowerCase()) {
            case "mcod": {
                McodClassifier classifier = new McodClassifier(metricColumns);
                classifier.setMaxDistance(conf.get("maxDistance", 1.0));
                classifier.setMinNeighborCount(conf.get("minNeighborCount", 30));
                classifier.setWindowSize(conf.get("classifierWindowSize", 9999));
                classifier.setSlide(conf.get("classifierSlide", 9999));
                classifier.setAllowDuplicates(conf.get("allowDuplicates", false));
                classifier.setTimeColumnName(conf.get("timeColumn"));
                return classifier;
            }
            case "percentile": {
                PercentileClassifier classifier = new PercentileClassifier(metricColumns[0]);
                classifier.setPercentile(conf.get("cutoff", 1.0));
                classifier.setIncludeHigh(conf.get("includeHi",true));
                classifier.setIncludeLow(conf.get("includeLo",true));
                return classifier;
            }
            case "predicate": {
                String predicateStr = conf.get("predicate", "==").trim();
                Object rawCutoff = conf.get("cutoff");
                boolean isStrPredicate = rawCutoff instanceof String;
                if (isStrPredicate){
                    return new PredicateClassifier(metricColumns[0], predicateStr, (String) rawCutoff);
                }
                return new PredicateClassifier(metricColumns[0], predicateStr, conf.get("cutoff", 1.0));
            }
            case "mad": {
                MAD classifier = new MAD(metricColumns[0]);
                classifier.setTrainSize(conf.get("trainSize", 10000));
                return classifier;
            }
            case "mcd": {
                MinCovDet classifier = new MinCovDet(metricColumns);
                classifier.setTrainSize(conf.get("trainSize", 10000));
                classifier.setAlpha(conf.get("alpha", 0.5));
                classifier.setStoppingDelta(conf.get("stoppingDelta", 0.001));
                return classifier;
            }
            case "lof-chen": {
                alexp.macrobase.outlier.lof.chen.LOF classifier = new alexp.macrobase.outlier.lof.chen.LOF(metricColumns);
                classifier.setTrainSize(conf.get("trainSize", 10000));
                classifier.setParallel(conf.get("parallel", true));
                classifier.setSearchRange(conf.get("minPtsLB"), conf.get("minPtsUB"));
                return classifier;
            }
            case "lof-bkaluza": {
                LOF classifier = new LOF(metricColumns, LOF.Distance.EUCLIDIAN);
                classifier.setTrainSize(conf.get("trainSize", 10000));
                classifier.setkNN(conf.get("knn", 5));
                return classifier;
            }
            default: {
                throw new RuntimeException("Bad Classifier Type " + classifierType);
            }
        }
    }

    public static Operator<DataFrame, ? extends Explanation> getSummarizer(PipelineConfig conf, String outlierColumn, List<String> attributes) throws MacroBaseException {
        String summarizerType = conf.get("summarizer", "apriori");
        switch (summarizerType.toLowerCase()) {
            case "fpgrowth": {
                FPGrowthSummarizer summarizer = new FPGrowthSummarizer();
                summarizer.setOutlierColumn(outlierColumn);
                summarizer.setAttributes(attributes);
                summarizer.setMinSupport(conf.get("minSupport", 0.01));
                summarizer.setMinRiskRatio(conf.get("minRatioMetric", 3.0));
                summarizer.setUseAttributeCombinations(true);
                summarizer.setNumThreads(conf.get("numThreads", Runtime.getRuntime().availableProcessors()));
                return summarizer;
            }
            case "apriori":
            case "aplinear": {
                APLOutlierSummarizer summarizer = new APLOutlierSummarizer();
                summarizer.setOutlierColumn(outlierColumn);
                summarizer.setAttributes(attributes);
                summarizer.setMinSupport(conf.get("minSupport", 0.01));
                summarizer.setMinRatioMetric(conf.get("minRatioMetric", 3.0));
                summarizer.setNumThreads(conf.get("numThreads", Runtime.getRuntime().availableProcessors()));
                return summarizer;
            }
            case "incremental": {
                IncrementalSummarizer summarizer = new IncrementalSummarizer();
                summarizer.setOutlierColumn(outlierColumn);
                summarizer.setAttributes(attributes);
                summarizer.setMinSupport(conf.get("minSupport", 0.01));
                summarizer.setWindowSize(conf.get("numPanes", 3));
                return summarizer;
            }
            case "windowed": {
                IncrementalSummarizer summarizer = new IncrementalSummarizer();
                summarizer.setOutlierColumn(outlierColumn);
                summarizer.setAttributes(attributes);
                summarizer.setMinSupport(conf.get("minSupport", 0.01));

                WindowedOperator<FPGExplanation> windowedSummarizer = new WindowedOperator<>(summarizer);
                windowedSummarizer.setWindowLength(conf.get("windowLength", 6000));
                windowedSummarizer.setSlideLength(conf.get("slideLength", 1000));
                windowedSummarizer.setTimeColumn(conf.get("timeColumn"));
                windowedSummarizer.initialize();

                return windowedSummarizer;
            }
            default: {
                throw new MacroBaseException("Bad Summarizer Type " + summarizerType);
            }
        }
    }

    public static boolean isAutoGeneratedColumn(String column) {
        return column != null && column.startsWith("__");
    }

    public static void generatedTimeColumn(DataFrame dataFrame, String column, long start) {
        double[] time = LongStream.rangeClosed(start, dataFrame.getNumRows() + start).mapToDouble(n -> (double) n).toArray();
        dataFrame.addColumn(column, time);
    }
}
