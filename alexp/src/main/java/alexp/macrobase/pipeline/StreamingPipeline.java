package alexp.macrobase.pipeline;

import alexp.macrobase.ingest.HttpCsvStreamReader;
import alexp.macrobase.ingest.SqlStreamReader;
import alexp.macrobase.ingest.StreamingDataFrameLoader;
import alexp.macrobase.ingest.Uri;
import com.google.common.base.Stopwatch;
import edu.stanford.futuredata.macrobase.analysis.classify.Classifier;
import edu.stanford.futuredata.macrobase.analysis.summary.Explanation;
import edu.stanford.futuredata.macrobase.analysis.summary.fpg.FPGExplanation;
import edu.stanford.futuredata.macrobase.analysis.summary.fpg.IncrementalSummarizer;
import edu.stanford.futuredata.macrobase.datamodel.DataFrame;
import edu.stanford.futuredata.macrobase.datamodel.Schema;
import edu.stanford.futuredata.macrobase.operator.Operator;
import edu.stanford.futuredata.macrobase.operator.WindowedOperator;
import edu.stanford.futuredata.macrobase.pipeline.PipelineConfig;
import edu.stanford.futuredata.macrobase.util.MacroBaseException;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamingPipeline extends Pipeline {
    private final PipelineConfig conf;

    private final Uri inputURI;

    private String idColumn;
    private String sqlQuery;

    private Integer maxReadBatchSize;

    private String[] metricColumns;

    private boolean isStrPredicate;

    private String summarizerType;
    private List<String> attributes;
    private double minSupport;

    private Integer numPanes;
    private Integer windowLength;
    private Integer slideLength;
    private String timeColumn;

    public StreamingPipeline(PipelineConfig conf) {
        this.conf = conf;

        inputURI = new Uri(conf.get("inputURI"));

        //noinspection unchecked
        metricColumns = ((List<String>) conf.get("metricColumns")).toArray(new String[0]);

        if (inputURI.getType() == Uri.Type.JDBC) {
            sqlQuery = conf.get("query");
            idColumn = conf.get("idColumn", "id");
        }

        maxReadBatchSize = conf.get("maxReadBatchSize", 5000);

        String classifierType = conf.get("classifier", "percentile");
        if (classifierType.equals("predicate")) {
            Object rawCutoff = conf.get("cutoff");
            isStrPredicate = rawCutoff instanceof String;
        }

        summarizerType = conf.get("summarizer", "apriori");
        attributes = conf.get("attributes");
        minSupport = conf.get("minSupport", 0.01);

        numPanes = conf.get("numPanes", 3);
        windowLength = conf.get("windowLength", 6000);
        slideLength = conf.get("slideLength", 1000);
        timeColumn = conf.get("timeColumn", "id");
    }

    public void run(Consumer<Explanation> resultCallback) throws Exception {
        StreamingDataFrameLoader dataLoader = getDataLoader();

        Classifier classifier = Pipelines.getClassifier(conf, metricColumns);
        Operator<DataFrame, ? extends Explanation> summarizer = getSummarizer(classifier.getOutputColumnName());

        AtomicLong totalClassifierMs = new AtomicLong();
        AtomicLong totalExplanationMs = new AtomicLong();

        dataLoader.load(dataFrame -> {
            createAutoGeneratedColumns(dataFrame, timeColumn);

            Stopwatch sw = Stopwatch.createStarted();

            classifier.process(dataFrame);

            final long classifierMs = sw.elapsed(TimeUnit.MILLISECONDS);
            totalClassifierMs.addAndGet(classifierMs);
            sw = Stopwatch.createStarted();

            summarizer.process(classifier.getResults());

            final long explanationMs = sw.elapsed(TimeUnit.MILLISECONDS);
            totalExplanationMs.addAndGet(explanationMs);

            System.out.printf("Classification time: %d ms (total %d ms)\nSummarization time: %d ms (total %d ms)\n\n",
                    classifierMs, totalClassifierMs.get(), explanationMs, totalExplanationMs.get());

            resultCallback.accept(summarizer.getResults());
        });
    }

    private StreamingDataFrameLoader getDataLoader() throws Exception {
        Map<String, Schema.ColType> colTypes = new HashMap<>();
        Schema.ColType metricType = isStrPredicate ? Schema.ColType.STRING : Schema.ColType.DOUBLE;
        for (String column : metricColumns) {
            colTypes.put(column, metricType);
        }

        List<String> requiredColumns = Stream.concat(attributes.stream(), colTypes.keySet().stream()).collect(Collectors.toList());
        requiredColumns.add(idColumn);
        requiredColumns = requiredColumns.stream().filter(c -> c != null && !Pipelines.isAutoGeneratedColumn(c)).collect(Collectors.toList());

        switch (inputURI.getType()) {
            case HTTP:
                return new HttpCsvStreamReader(inputURI.getPath(), requiredColumns)
                        .setColumnTypes(colTypes);
            case JDBC:
                return new SqlStreamReader(inputURI.getPath(), requiredColumns, sqlQuery, idColumn)
                        .setColumnTypes(colTypes)
                        .setMaxBatchSize(maxReadBatchSize);
            default:
                throw new Exception("Unsupported input protocol");
        }
    }

    private Operator<DataFrame, ? extends Explanation> getSummarizer(String outlierColumnName) throws MacroBaseException {
        switch (summarizerType.toLowerCase()) {
            case "incremental": {
                IncrementalSummarizer summarizer = new IncrementalSummarizer();
                summarizer.setOutlierColumn(outlierColumnName);
                summarizer.setAttributes(attributes);
                summarizer.setMinSupport(minSupport);
                summarizer.setWindowSize(numPanes);
                return summarizer;
            }
            case "windowed": {
                IncrementalSummarizer summarizer = new IncrementalSummarizer();
                summarizer.setOutlierColumn(outlierColumnName);
                summarizer.setAttributes(attributes);
                summarizer.setMinSupport(minSupport);

                WindowedOperator<FPGExplanation> windowedSummarizer = new WindowedOperator<>(summarizer);
                windowedSummarizer.setWindowLength(windowLength);
                windowedSummarizer.setSlideLength(slideLength);
                windowedSummarizer.setTimeColumn(timeColumn);
                windowedSummarizer.initialize();

                return windowedSummarizer;
            }
            default: {
                throw new MacroBaseException("Bad Summarizer Type");
            }
        }
    }
}
